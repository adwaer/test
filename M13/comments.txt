1) для начала я открыл статью про .net core (потому как им я не пользовался)
2) Проверил Program.cs, посмотрел все параметры + удалил неиспользуемые юзинги
3) в Startup добавил страницы исключения для дев версии хоста
4) ValuesController нужно отрефачить, потому как намешали 2 апи несвязанных с values
5) Rest подход не подходит (судя по роутам в комментах), поэтому используем action api
6) Раскидываем апи на разные контроллеры без кастомных роутов 
7) Для простоты дебаггинга добавил Swagger (чтобы не заморачиваться конфиги оставляем почти дефолтными)
8) RulesController: 
ставим экшн апи роут: [Route("api/[controller]/[action]")]
Rules выносим в сервис + делаем di singleton
Я не знаю как в Asp.net core принято (стоит еще почитать), но довольно таки странно выглядят возвращаемые значения. Переделал на IActionResult как привык + добавим асинхронности
придерживаемся var спецификации - убираем типизированные инициалзации переменных
в методе Test добавим еще стринг билдер
в методе Delete меняем try catch для того увидеть непредвиденную ошибку
в методе Rules возвращаем объект для json сериализации
Для поддерджки rest спецификации сделал ключевой параметр site именованном id (добавив коммент)
Остался в шоке о того что нужно явно прописыват атрибуты для вербов если не в гет запросах параметр id
Нельзя просто так взять и прописать глобальный роут который бы сработал, он обязательно должен висеть над каком нибудь контроллером

SpellsController:
лучше юзать множественное число для энпоинтов
вынес requestService т.к. логика повторяется
инициализировать список со старта в 100 ячеек тоже расточительство, лучше после запроса взять конкретное число
SpellErrorsCount - зачем юзать Count(), он же будет проверять тип коллекции. Раз уж мы и так знаем что это лист почему бы сразу коунт не взять 
SpellerErrors - нужно сделать классом, т.к. объект большой и это будет затратно по памяти все время копировать его
Зачем синг инстанс HttpClientFactory, нет никакой работы с общей памятью?  + раз уж это фактори зачем его оборачивать в другое фактори? да и стоило бы по умнее этот фактори сделать
Лучше вообще сделать его статичным
Не вижу смысла выносить GetErrors в отдельный класс, интеграцию внутри бы вынести в интеграционную бизнес логику, сборку списка можно вынести в Rx Observable или подобный аналог yield-return
зачем в методе создавать вручную HttpClient при живом то всемогущем HttpClientFactory?
строки конкатить лучше по новому, молодежному, через $"{}"

Метод Test перенес к спелам, т.к. подобный метод + разгрузить RulesController от реквест сервиса

Для возвращаемых и передаваемых значений лучше использовать ViewModel в целях валидации, типизации и т.п.
Я конечно не проверял как устроено в .net core, однако асинхронные операции выполнять через Result может привести к дедлокам. Да и зачем блокировать потоки, расточительство ай ай ай
Нужно писать комменты хотя для всех ViewModel и методов контроллеров для того чтобы можно было получать доку
Валидацию xpath не стал делать, просто заметим что я обратил внимание на это :)
Язык спецификации лучше утвердить и пользоваться только одном
Конфиг в стартапе лучше разнести

В целом я не ошибался в том, что пока что не пользовался .net core (опираясь на мнения разработчиков которые пользовались). Даже в таком маленьком приложении я получил неадекватно реагирущий сервер